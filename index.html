<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <title>work tool</title>
    </head>

    <body>
        <app></app>

        <script>
            ((window) => {
                const SECOND = 1;
                const MINUTE = SECOND * 60;
                const HOUR = MINUTE * 60;
                const DAY = HOUR * 24;

                class CookieUtils {
                    static get(name) {
                        if (typeof name !== 'string' || name.trim() === '') {
                            return null;
                        }

                        const encodedName = encodeURIComponent(name);
                        const cookie = `; ${document.cookie}`;
                        const value = cookie.split(`; ${encodedName}=`);

                        if (value.length === 2) {
                            return decodeURIComponent(value[1].split(';')[0]);
                        }

                        return null;
                    }

                    /**
                     * @param {string} name
                     * @param {string} value
                     * @param {number} expires - seconds
                     */
                    static set(name, value, expires) {
                        if (typeof name !== 'string' || name.trim() === '') {
                            return;
                        }

                        if (value === null || value === undefined) {
                            return;
                        }

                        if (typeof expires !== 'number' || expires < 0) {
                            return;
                        }

                        const encodedName = encodeURIComponent(name);
                        const encodedValue = encodeURIComponent(String(value));

                        document.cookie = `${encodedName}=${encodedValue}; max-age=${expires}; path=/; Secure; SameSite=None`;
                    }
                }

                class HashAdapter {
                    async hash(text) {
                        const msgUint8 = new TextEncoder().encode(text);
                        const hashBuffer = await crypto.subtle.digest('SHA-256', msgUint8);
                        const hashArray = Array.from(new Uint8Array(hashBuffer));
                        const hashHex = hashArray.map((b) => b.toString(16).padStart(2, '0')).join('');

                        return hashHex;
                    }
                }

                class DatabaseAdapterBase {
                    static STORES = {
                        USER: 'user',
                        SESSION: 'session',
                    };
                    static STORE_CONFIG = {
                        [DatabaseAdapterBase.STORES.USER]: { keyPath: 'id' },
                        [DatabaseAdapterBase.STORES.SESSION]: { keyPath: 'id' },
                    };

                    constructor() {
                        if (new.target === DatabaseAdapterBase) {
                            throw new Error('Cannot instantiate abstract class');
                        }
                    }

                    async setup() {
                        throw new Error('Override required');
                    }

                    async insert(storeName, key, value) {
                        throw new Error('Override required');
                    }

                    async selectAll(storeName, key) {
                        throw new Error('Override required');
                    }

                    async select(storeName, key) {
                        throw new Error('Override required');
                    }

                    async isExists(storeName, key) {
                        throw new Error('Override required');
                    }

                    async update(storeName, key, value) {
                        throw new Error('Override required');
                    }

                    async delete(storeName, key) {
                        throw new Error('Override required');
                    }
                }

                class IndexedDBAdapter extends DatabaseAdapterBase {
                    static TRANSACTION = {
                        READWRITE: 'readwrite',
                        READONLY: 'readonly',
                    };
                    static NAME = 'work_tool_db';
                    static VERSION = 1;

                    constructor() {
                        super();

                        this.db = null;
                    }

                    async setup() {
                        await this.#open();
                    }

                    #open() {
                        return new Promise((resolve, reject) => {
                            const request = indexedDB.open(IndexedDBAdapter.NAME, IndexedDBAdapter.VERSION);

                            request.onupgradeneeded = (event) => {
                                const db = event.target.result;

                                for (const storeName of Object.values(DatabaseAdapterBase.STORES)) {
                                    if (!db.objectStoreNames.contains(storeName)) {
                                        db.createObjectStore(storeName, DatabaseAdapterBase.STORE_CONFIG[storeName]);
                                    }
                                }
                            };

                            request.onsuccess = (event) => {
                                this.db = event.target.result;

                                resolve(true);
                            };

                            request.onerror = () => {
                                console.error(request.error);

                                reject(new Error('IndexedDB open failed'));
                            };

                            request.onblocked = () => {
                                reject(new Error('IndexedDB open blocked'));
                            };
                        });
                    }

                    insert(storeName, key, value) {
                        const preparedValue = this.#prepareValue(storeName, key, value);

                        return this.#query(storeName, 'readwrite', (store) => {
                            return store.add(preparedValue);
                        });
                    }

                    selectAll(storeName) {
                        return this.#query(storeName, IndexedDBAdapter.TRANSACTION.READONLY, (store) => {
                            return store.getAll();
                        });
                    }

                    select(storeName, key) {
                        return this.#query(storeName, IndexedDBAdapter.TRANSACTION.READONLY, (store) => {
                            return store.get(key);
                        });
                    }

                    isExists(storeName, key) {
                        return this.#query(storeName, IndexedDBAdapter.TRANSACTION.READONLY, (store) => {
                            return store.getKey(key);
                        });
                    }

                    update(storeName, key, value) {
                        const preparedValue = this.#prepareValue(storeName, key, value);

                        return this.#query(storeName, IndexedDBAdapter.TRANSACTION.READWRITE, (store) => {
                            return store.put(preparedValue);
                        });
                    }

                    delete(storeName, key) {
                        return this.#query(storeName, IndexedDBAdapter.TRANSACTION.READWRITE, (store) => {
                            return store.delete(key);
                        });
                    }

                    #prepareValue(storeName, key, value) {
                        const config = DatabaseAdapterBase.STORE_CONFIG[storeName];
                        if (!config) {
                            throw new Error('Invalid storeName');
                        }

                        value[config.keyPath] = key;

                        return value;
                    }

                    #query(storeName, mode, operation) {
                        return new Promise((resolve, reject) => {
                            const transaction = this.db.transaction(storeName, mode);
                            const store = transaction.objectStore(storeName);

                            const request = operation(store);

                            request.onsuccess = () => {
                                resolve(request.result);
                            };

                            request.onerror = () => {
                                reject(request.error);
                            };
                        });
                    }

                    close() {
                        if (this.db !== null) {
                            this.db.close();
                        }

                        this.db = null;
                    }
                }

                class EntityBase {
                    constructor(key) {
                        if (new.target === EntityBase) {
                            throw new Error('Cannot instantiate abstract class');
                        }

                        this.key = key;
                    }

                    getKey() {
                        return this.key;
                    }

                    getValue() {
                        const { key, ...data } = this;
                        return data;
                    }
                }

                class UserEntity extends EntityBase {
                    constructor(key, params) {
                        super(key);

                        this.username = params?.username ?? '';
                        this.password = params?.password ?? '';
                    }

                    getPassword() {
                        return this.password;
                    }
                }

                class SessionEntity extends EntityBase {
                    constructor(key, params) {
                        super(key);

                        /** @type {number|null} 만료 시간 (단위: ms) */
                        this.expires = params?.expires ?? null;
                    }

                    isValid(now) {
                        if (this.expires === null) {
                            return false;
                        }

                        return now <= this.expires;
                    }
                }

                class ModelBase {
                    constructor() {
                        if (new.target === ModelBase) {
                            throw new Error('Cannot instantiate abstract class');
                        }
                    }
                }

                class UserModel extends ModelBase {
                    constructor(dependency) {
                        super();

                        this.storeName = DatabaseAdapterBase.STORES.USER;

                        /** @type {DatabaseAdapterBase} */
                        this.db = dependency?.databaseAdapter;
                    }

                    /**
                     * @param {UserEntity} user
                     */
                    async create(user) {
                        const key = user.getKey();
                        const value = user.getValue();

                        try {
                            const result = await this.db.insert(this.storeName, key, value);

                            return result;
                        } catch (error) {
                            console.error(error);
                            return false;
                        }
                    }

                    async getById(id) {
                        try {
                            const result = await this.db.select(this.storeName, id);

                            if (!result) {
                                return null;
                            }

                            return new UserEntity(id, result);
                        } catch (error) {
                            console.error(error);
                            return null;
                        }
                    }

                    async has(id) {
                        try {
                            const result = await this.db.isExists(this.storeName, id);

                            return Boolean(result);
                        } catch (error) {
                            console.error(error);
                            return false;
                        }
                    }
                }

                class SessionModel extends ModelBase {
                    constructor(dependency) {
                        super();

                        this.storeName = DatabaseAdapterBase.STORES.SESSION;

                        /** @type {DatabaseAdapterBase} */
                        this.db = dependency?.databaseAdapter;
                    }

                    /**
                     * @param {SessionEntity} session
                     */
                    async create(session) {
                        const key = session.getKey();
                        const value = session.getValue();

                        try {
                            const result = await this.db.insert(this.storeName, key, value);

                            return result;
                        } catch (error) {
                            console.error(error);
                            return false;
                        }
                    }

                    async getById(id) {
                        try {
                            const result = await this.db.select(this.storeName, id);

                            if (!result) {
                                return null;
                            }

                            return new SessionEntity(id, result);
                        } catch (error) {
                            console.error(error);
                            return null;
                        }
                    }
                }

                class ServiceBase {
                    constructor() {
                        if (new.target === ServiceBase) {
                            throw new Error('Cannot instantiate abstract class');
                        }
                    }
                }

                class CryptoService extends ServiceBase {
                    constructor(dependency) {
                        super();

                        /** @type {HashAdapter} */
                        this.hashAdapter = dependency.hashAdapter;
                    }

                    async hash(...args) {
                        const data = args.join(':');

                        return await this.hashAdapter.hash(data);
                    }

                    async verifyPassword(password, hashedPassword) {
                        if (!password || !hashedPassword) {
                            return false;
                        }

                        return (await this.hash(password)) === hashedPassword;
                    }
                }

                class UserService extends ServiceBase {
                    constructor(dependency) {
                        super();

                        /** @type {CryptoService} */
                        this.cryptoService = dependency.cryptoService;
                        /** @type {UserModel} */
                        this.model = dependency.model;
                    }

                    async register(username, password) {
                        const userId = await this.cryptoService.hash(username);
                        const hashedPassword = await this.cryptoService.hash(password);

                        const newUser = new UserEntity(userId, {
                            username,
                            password: hashedPassword,
                        });

                        const result = await this.model.create(newUser);

                        return result;
                    }

                    async login(username, password) {
                        const user = await this.#getUser(username);

                        if (user === null) {
                            return false;
                        }

                        const isValid = await this.#verifyPassword(user, password);

                        if (!isValid) {
                            return false;
                        }

                        return true;
                    }

                    async #getUser(username) {
                        const userId = await this.cryptoService.hash(username);

                        const user = await this.model.getById(userId);

                        return user;
                    }

                    /**
                     * @param {UserEntity} user
                     * @param {string} password
                     */
                    async #verifyPassword(user, password) {
                        const stored = user.getPassword();

                        return await this.cryptoService.verifyPassword(password, stored);
                    }
                }

                class SessionService extends ServiceBase {
                    static SESSION_COOKIE = 'session';
                    static SESSION_COOKIE_EXPRISE = 12 * HOUR;

                    constructor(dependency) {
                        super();

                        /** @type {CryptoService} */
                        this.cryptoService = dependency.cryptoService;
                        /** @type {SessionModel} */
                        this.model = dependency.model;
                    }

                    async create(username) {
                        const nowMs = Date.now();
                        const sessionId = await this.cryptoService.hash(username, nowMs);

                        const session = new SessionEntity(sessionId, {
                            expires: nowMs + SessionService.SESSION_COOKIE_EXPRISE * 1000,
                        });

                        const result = await this.model.create(session);

                        if (!result) {
                            return false;
                        }

                        CookieUtils.set(SessionService.SESSION_COOKIE, session.getKey(), SessionService.SESSION_COOKIE_EXPRISE);

                        return true;
                    }

                    async isAuthenticated() {
                        /** @type {SessionEntity} */
                        const session = await this.#get();

                        if (session === undefined || session === null || !session.isValid(Date.now())) {
                            return false;
                        }

                        return true;
                    }

                    async #get() {
                        const sessionId = CookieUtils.get(SessionService.SESSION_COOKIE);

                        if (!sessionId) {
                            return null;
                        }

                        const session = await this.model.getById(sessionId);

                        return session;
                    }
                }

                class AuthenticationService extends ServiceBase {
                    constructor(dependency) {
                        super();

                        /** @type {UserService} */
                        this.userService = dependency.userService;
                        /** @type {SessionService} */
                        this.sessionService = dependency.sessionService;
                    }

                    async isLogin() {
                        const isAuthenticated = await this.sessionService.isAuthenticated();

                        if (!isAuthenticated) {
                            return false;
                        }

                        return true;
                    }

                    async login(username, password) {
                        const result = await this.userService.login(username, password);

                        if (!result) {
                            return false;
                        }

                        await this.sessionService.create(username);

                        return true;
                    }
                }

                class ViewManager {
                    static VIEWS = {
                        HOME: 'home_view',
                        LOGIN: 'login_view',
                    };

                    constructor(dependency) {
                        /** @type {DIContainer} */
                        this.di = dependency.di;

                        this.container = document.querySelector('app');
                        this.views = new Map();
                        this.state = {};
                    }

                    async navigate(viewName) {
                        /** @type {ViewBase} */
                        let viewElement = this.views.get(viewName);

                        if (!viewElement) {
                            viewElement = document.createElement(viewName);

                            this.views.set(viewName, viewElement);
                        }

                        this.container.innerHTML = '';
                        this.container.appendChild(viewElement);

                        if (typeof viewElement.setup === 'function') {
                            await viewElement.setup(this.di);
                        }
                    }
                }

                class ComponentBase extends HTMLElement {
                    constructor() {
                        super();

                        if (new.target === ComponentBase) {
                            throw new Error('Cannot instantiate abstract class');
                        }
                    }

                    render() {
                        throw new Error('Override required');
                    }
                }

                class ViewBase extends ComponentBase {
                    constructor() {
                        super();

                        if (new.target === ViewBase) {
                            throw new Error('Cannot instantiate abstract class');
                        }

                        this.state = {};
                    }

                    async setup(di) {
                        throw new Error('Override required');
                    }
                }

                class HomeView extends ViewBase {
                    constructor() {
                        super();
                    }

                    async setup(di) {
                        this.#setupDependency(di);
                        await this.#setupState();
                    }

                    /** @param {Map} di */
                    async #setupDependency(di) {
                        this.authnService = di.get('authnService');
                    }

                    async #setupState() {
                        this.state.isLogin = await this.authenticationService.isLogin();
                    }
                }

                class LoginView extends ViewBase {
                    constructor() {
                        super();
                    }

                    async setup(di) {
                        this.#setupDependency(di);
                        await this.#setupState();
                    }

                    /** @param {Map} di */
                    async #setupDependency(di) {
                        this.authnService = di.get('authnService');
                    }

                    async #setupState() {
                        this.state.isLogin = await this.authenticationService.isLogin();
                    }

                    render() {
                        this.innerHTML = `
                            <section id="login_view" class="view">
                                <h2>Login</h2>

                                <form id="login_form">
                                    <label>
                                        username:
                                        <input type="text" name="username" required />
                                    </label>
                                    <label>
                                        password:
                                        <input type="password" name="password" required />
                                    </label>
                                    <button type="submit">login</button>
                                </form>
                            </section>
                        `;
                    }

                    async #handleLogin(event) {
                        event.preventDefault();

                        const formData = new FormData(event.target);

                        const username = formData.get('username');
                        const password = formData.get('password');

                        const result = await this.authenticationService.login(username, password);

                        if (result) {
                            this.state.isLogin = true;

                            this.root.update();
                        } else {
                            alert('login failed');
                        }
                    }
                }

                class Button extends ComponentBase {
                    constructor() {
                        super();
                    }

                    render() {
                        this.innerHTML = `
                            <button></button>
                        `;
                    }
                }

                class DI {
                    static DATABASE = 'database';
                    static AUTHN_SERVICE = 'authnService';

                    constructor() {
                        this.container = new Map();
                    }

                    async bootstrap() {
                        this.#setup();

                        /** @type {DatabaseAdapterBase} */
                        const database = this.container.get(DI.DATABASE);

                        await database.setup();
                    }

                    #setup() {
                        const hashAdapter = new HashAdapter();
                        const databaseAdapter = new IndexedDBAdapter();

                        const userModel = new UserModel({ databaseAdapter });
                        const sessionModel = new SessionModel({ databaseAdapter });

                        const cryptoService = new CryptoService({ hashAdapter });
                        const userService = new UserService({ cryptoService, userModel });
                        const sessionService = new SessionService({ cryptoService, sessionModel });
                        const authenticationService = new AuthenticationService({ userService, sessionService });

                        this.container.set(DI.DATABASE, databaseAdapter);
                        this.container.set(DI.AUTHN_SERVICE, authenticationService);
                    }

                    get(name) {
                        const dependency = this.container.get(name);

                        if (!dependency) {
                            throw new Error('Invalid name');
                        }

                        return dependency;
                    }
                }

                class App {
                    constructor() {
                        this.di = new DI();
                        this.viewManager = new ViewManager({ di: this.di });
                    }

                    async run() {
                        const success = await this.#boot();

                        if (!success) {
                            return;
                        }

                        this.viewManager.navigate(ViewManager.VIEWS.HOME);
                    }

                    async #boot() {
                        try {
                            await this.di.bootstrap();

                            return true;
                        } catch (error) {
                            console.error(error);

                            return false;
                        }
                    }
                }

                window.App = App;
            })(window);

            const app = new App();

            app.run();
        </script>
    </body>
</html>
